srv.on('UpdateStatusComments', async (req) => {

    const { id, action, comments, module } = req.data;

    var actionType = ""
    if (action === "reject") {
      actionType = "rejected";
      console.log(actionType)
    }
    if (action === "approve") {
      actionType = "approved";


      const containerName = await db.run(
        SELECT
          .from('com.scb.fileupload.master.ModuleContainerMap')
          .columns('CONTAINER_NAME')
          .where({ MODULE_NAME: module })
      );

      const { CONTAINER_NAME } = containerName[0];

      try {
        // Use db.run() and let HANA return OUT param as a record
        const sql = `
      DO BEGIN
        DECLARE v_result NVARCHAR(500);
        CALL "${CONTAINER_NAME}"."GENERIC_DATA_LOADER"(ID => '${id}', V_OUT => v_result);
        SELECT :v_result AS V_OUT FROM DUMMY;
      END;
    `
        console.log(id);
        console.log(sql)
        const result = await db.run(sql)
        console.log(result);

      } catch (error) {
        req.error(500, `Proc call failed: ${error.message}`);
      }

      console.log(actionType)
    }
    if (!id) return req.error(400, "ID is required");
    if (!action) return req.error(400, "Action is required");

    try {


      const updated = await UPDATE('com.scb.fileupload.master.ReportFileStorage')
        .set({
          STATUS: actionType,
          COMMENTS: comments?.substring(0, 300) || null
        })
        .where({ ID: id });

      if (updated === 0) {
        return `No record found for ID ${id}`;
      }
      console.log(req.user);
      const updateUser = await UPDATE('com.scb.fileupload.master.ReportFileStorage')
        .set({
          ACTION_BY: req.user.id
        })
        .where({ ID: id });

      //add 3 audit trail logs here

      await UPDATE('com.scb.fileupload.master.AuditTrailReport')
        .set({ STATUS: actionType })
        .where({ REPORT_ID: id });

      await UPDATE('com.scb.fileupload.master.AuditTrailReport')
        .set({ ACTION_BY: req.user.id })
        .where({ REPORT_ID: id });

      await UPDATE('com.scb.fileupload.master.AuditTrailReport')
        .set({ ACTION_AT: new Date() })
        .where({ REPORT_ID: id });

      // Return professional message
      if (action === "approve") {
        return `Record approved successfully`;
      }
      if (action === "reject") {
        return `Record rejected successfully`;
      }

    } catch (err) {
      req.error(500, `Database update failed: ${err.message}`);
    }

  });

This is my code

{
	"NFRA_OVERLAY": {
		"application_user": {
			"schema_privileges": [
				{
					"schema": "T1NFRP_PHY",
					"privileges": [
						"EXECUTE",
						"SELECT",
						"SELECT METADATA",
						"INSERT",
						"DELETE"
					],
					"privileges_with_grant_option": [
						"EXECUTE",
						"SELECT",
						"SELECT METADATA",
						"INSERT",
						"DELETE"
					]
				}
			]
		},
		"object_owner": {
			"schema_privileges": [
				{
					"schema": "T1NFRP_PHY",
					"privileges": [
						"EXECUTE",
						"SELECT",
						"SELECT METADATA",
						"INSERT",
						"DELETE"
					],
					"privileges_with_grant_option": [
						"EXECUTE",
						"SELECT",
						"SELECT METADATA",
						"INSERT",
						"DELETE"
					]
				}
			]
		}
	}
}

This is my grants file for NFRP in T1GDTL_PHY container

{
  "COM_SCB_FILEUPLOAD_MASTER_REPORTFILESTORAGE": {
    "target": {
      "object": "COM_SCB_FILEUPLOAD_MASTER_REPORTFILESTORAGE",
      "schema": "T1GDTL_PHY"
    }
  }
}

This is the COM_SCB_FILEUPLOAD_MASTER_REPORTFILESTORAGE synonym

{
  "COM_SCB_FILEUPLOAD_MASTER_LOADTABLE": {
    "target": {
      "object": "COM_SCB_FILEUPLOAD_MASTER_LOADTABLE",
      "schema": "T1GDTL_PHY"
    }
  }
}

This is the COM_SCB_FILEUPLOAD_MASTER_LOADTABLE synonym

{
  "COM_SCB_FILEUPLOAD_MASTER_LOADMAP": {
    "target": {
      "object": "COM_SCB_FILEUPLOAD_MASTER_LOADMAP",
      "schema": "T1GDTL_PHY"
    }
  }
}
This is the COM_SCB_FILEUPLOAD_MASTER_LOADMAP synonym

{
	"FINSIGHT_OVERLAY": {
		"application_user": {
			"schema_privileges": [
				{
					"schema": "T1GDTL_PHY",
					"privileges": [
						"SELECT",
						"SELECT METADATA"
					],
					"privileges_with_grant_option": [
						"SELECT",
						"SELECT METADATA"
					]
				}
			]
		},
		"object_owner": {
			"schema_privileges": [
				{
					"schema": "T1GDTL_PHY",
					"privileges": [
						"SELECT",
						"SELECT METADATA"
					],
					"privileges_with_grant_option": [
						"SELECT",
						"SELECT METADATA"
					]
				}
			]
		}
	}
}

This the t1gdtl grant file in the NFRp container
