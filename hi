Controller code

onUploadPress: async function () {
      const module = this.byId("moduleComboBox").getSelectedKey();
      const subModule = this.byId("subModuleComboBox").getSelectedKey();
      const template = this.byId("loadTemplateComboBox").getSelectedKey();
      const oFileUploader = this.byId("fileUploader");
      console.log(oFileUploader);
      const file = oFileUploader.getDomRef("fu").files?.[0];

      if (!module || !subModule || !template || !file) {
        sap.m.MessageBox.error("Please select all dropdowns and choose a file.");
        return;
      }

      const maxSize = 20 * 1024 * 1024;
      if (file.size > maxSize) {
        sap.m.MessageBox.alert("File size exceeds 20 MB. Please upload a smaller file`.");
        return; // stop further execution
      }
      sap.ui.core.BusyIndicator.show(0);

      const reader = new FileReader();
      reader.onload = async () => {
        const base64Content = reader.result.split(",")[1];

        const payload = {
          MODULE_NAME: module,
          SUB_MODULE_NAME: subModule,
          LOAD_TEMPLATE: template,
          FILE_NAME: file.name,
          STATUS: "uploaded",
          FILE_MIME_TYPE: file.type,
          FILE_SIZE: file.size,
          FILE_CONTENT: base64Content
        };

        //Do validation here...
        var displayflag = false;
        const oFunction = this.oModel.bindContext("/ValidateTemplate(...)");
        oFunction.setParameter("FILE_CONTENT", base64Content);
        oFunction.setParameter("MODULE_NAME", module);
        oFunction.setParameter("SUB_MODULE_NAME", subModule);
        oFunction.setParameter("LOAD_TEMPLATE", template);
        oFunction.execute().then(() => {
          const oCtx = oFunction.getBoundContext();
          const data = oCtx.getObject();
          sap.ui.core.BusyIndicator.hide();
          if (data.flag === false) {
            if (data.message === "Invalid headers") {
              sap.m.MessageBox.error("Invalid headers");
              return;
            }
            else {
              sap.m.MessageBox.error(data.message);
              return;
            }
          } else {
            this._showPreviewDialog(payload);
          }
        });


      };

      reader.readAsDataURL(file);
    },

Service.js

srv.on("ValidateTemplate", async (req) => {
    const { MODULE_NAME, SUB_MODULE_NAME, LOAD_TEMPLATE, FILE_CONTENT } = req.data;

    //parse the excel and covert to JSON store it

    const buffer = Buffer.from(FILE_CONTENT, 'base64'); // If CONTENT is Base64 encoded

    const workbook = xlsx.read(buffer, { type: 'buffer' });
    const sheetName = workbook.SheetNames[0];
    const sheet = workbook.Sheets[sheetName];

    // Extract headers from the first row
    const headers = [];
    const range = xlsx.utils.decode_range(sheet["!ref"]);
    const firstRow = range.s.r; // starting row index

    for (let col = range.s.c; col <= range.e.c; col++) {
      const cellAddress = { c: col, r: firstRow };
      const cellRef = xlsx.utils.encode_cell(cellAddress);
      const cell = sheet[cellRef];
      let header = cell ? cell.v : undefined;
      headers.push(header);
    }
    const tx = cds.transaction(req);
    const headerData = await tx.run(

      SELECT.from('com.scb.fileupload.master.LoadMap')
        .columns("COLUMN_NAME", "COLUMN_DATATYPE", "CONSTRAINTS")
        .where({
          MODULE_NAME: MODULE_NAME,
          SUB_MODULE_NAME: SUB_MODULE_NAME,
          LOAD_TEMPLATE: LOAD_TEMPLATE
        })
        .orderBy('LOAD_COLUMN_SEQ')
    );


    const expectedHeaders = headerData.map(item => item.COLUMN_NAME);


    // Compare headers
    const isValidHeader =
      headers.length === expectedHeaders.length &&
      headers.every((h, i) => h === expectedHeaders[i]);

    if (!isValidHeader) {
      const result = {
        message: "Invalid headers",
        flag: isValidHeader
      }
      return result;
    } else {

      //check for datatype and constraints in each cell

      const headers = await tx.run(

        SELECT.from('com.scb.fileupload.master.LoadMap')
          .columns('COLUMN_NAME', 'COLUMN_DATATYPE', "CONSTRAINTS")
          .where({
            MODULE_NAME: MODULE_NAME,
            SUB_MODULE_NAME: SUB_MODULE_NAME,
            LOAD_TEMPLATE: LOAD_TEMPLATE
          })
          .orderBy('LOAD_COLUMN_SEQ')
      );
      const expectedColumns = headers.reduce((acc, item) => {
        const colName = item["COLUMN_NAME"].toUpperCase(); // optional: replace spaces with _
        const dataType = item["COLUMN_DATATYPE"].toUpperCase();   // make uppercase
        const constraint = item["CONSTRAINTS"]?.toUpperCase();    // added constraint
        acc[colName] = { dataType, constraint };
        return acc;
      }, {});

      // Convert sheet to JSON

      const jsonData = xlsx.utils.sheet_to_json(sheet, { defval: null });  //for to chck blank

      let errors = [];
      const MAX_ERRORS = 200;

      jsonData.forEach((row, rowIndex) => {
        if (errors.length >= MAX_ERRORS) {
          return; // stop collecting further errors
        }

        Object.keys(expectedColumns).forEach((col) => {
          if (errors.length >= MAX_ERRORS) {
            return; // stop inside column loop too
          }

          const { dataType, constraint } = expectedColumns[col]; //added constraint
          const value = row[col];


          if (constraint === "NOT NULL" && (value === null || value === "")) {
            errors.push(
              `Row ${rowIndex + 2}, Column "${col}" is NOT NULL but value is empty`
            );
          }

          if (!checkHanaType(value, dataType)) {
            if (dataType === 'DATE') {
              errors.push(
                `Row ${rowIndex + 2}, Column "${col}" expected ${dataType} (yyyy-MM-dd) but got "${value} "`
              );
            }
            else {
              errors.push(
                `Row ${rowIndex + 2}, Column "${col}" expected ${dataType} but got "${value}"`
              );
            }
          }
        });
      });


      var message1 = errors.length > 0 ? errors.join("\n") : "All datatypes and constraints are valid";
      if (message1 === "All datatypes and constraints are valid") {

        // generate UUID for dummy table
        const dummyId = cds.utils.uuid();

        // insert JSON into Dummy table
        await tx.run(
          INSERT.into("COM_SCB_FILEUPLOAD_MASTER_DUMMY").entries({
            ID: dummyId,
            JSON_DATA: JSON.stringify(jsonData)
          })
        );

        // call HANA procedure for duplicate validation
        const procResult = await tx.run(`
    CALL GENERIC_DATA_VALIDATOR(
      '${dummyId}',
      '${MODULE_NAME}',
      '${SUB_MODULE_NAME}',
      '${LOAD_TEMPLATE}',
      ?,
      ?
    )
  `);

        const procOut = procResult[0];
        const status = procOut.O_STATUS;
        const message = procOut.O_MESSAGE;

        // if duplicate found
        if (status === 'E') {

          // cleanup dummy data
          await tx.run(
            DELETE.from("COM_SCB_FILEUPLOAD_MASTER_DUMMY").where({ ID: dummyId })
          );

          return {
            message: message,
            flag: false
          };
        }

        // no duplicates â†’ proceed
        return {
          message: "Proceed",
          flag: true
        };

      } else {
        return {
          message: message1,
          flag: false
        };
      }

    }


  });


